# -*- coding: utf-8 -*-
"""spect.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Vh42_hS6gGdEuANw1Qr7Uxuwv10okuW8
"""

import numpy as np
import cv2 as cv
from matplotlib import pyplot as plt

# Read the images
img1 = cv.imread("s1.png")
img2 = cv.imread("s2.png")

# Set the figure size to control the overall size of the plot
fig, axes = plt.subplots(1, 2, figsize=(10, 5))

# Display the images side by side with spacing
axes[0].imshow(img1)
axes[0].set_title('Intensity Variation of Impure Ore Quality (Î»)')
axes[0].set_xticks([]), axes[0].set_yticks([])

axes[1].imshow(img2)
axes[1].set_title('Absorbance Variation of Ore with Time (t)')
axes[1].set_xticks([]), axes[1].set_yticks([])

# Adjust spacing between subplots
plt.subplots_adjust(wspace=0.5)  # You can adjust the value as needed

plt.show()

import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error
import matplotlib.pyplot as plt

# Load your dataset from Excel
excel_path = 'spectro_data.xlsx'
df = pd.read_excel(excel_path)

# Assuming 'Wavelength' is your input column and 'Concentration' is your target column
X = df[['Wavelength']]
y = df['Concentration']

# Split the dataset into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Create and train the Linear Regression model
linear_model = LinearRegression()
linear_model.fit(X_train, y_train)

# Make predictions on the test set
y_pred = linear_model.predict(X_test)

# Evaluate the model
mse = mean_squared_error(y_test, y_pred)
print(f'Mean Squared Error: {mse}')

# Plot the actual vs predicted values
plt.scatter(X_test, y_test, color='black', label='Actual')
plt.scatter(X_test, y_pred, color='red', marker='x', label='Predicted')
plt.xlabel('Wavelength')
plt.ylabel('Concentration')
plt.title('Linear Regression - Predicted vs Actual')
plt.legend()
plt.show()

import numpy as np
import cv2 as cv
from matplotlib import pyplot as plt

# Read the images
img1 = cv.imread("s3.jpg")
img2 = cv.imread("s4.png")

# Set the figure size to control the overall size of the plot
fig, axes = plt.subplots(1, 2, figsize=(10, 5))

# Display the images side by side with spacing
axes[0].imshow(img1)
axes[0].set_title('Libs Spectroscopy Method')
axes[0].set_xticks([]), axes[0].set_yticks([])

axes[1].imshow(img2)
axes[1].set_title('Spectral response for different types of Iron (Fe) Ores')
axes[1].set_xticks([]), axes[1].set_yticks([])

# Adjust spacing between subplots
plt.subplots_adjust(wspace=0.5)  # You can adjust the value as needed

plt.show()

import pandas as pd
import numpy as np
import cv2 as cv
from matplotlib import pyplot as plt
from sklearn.model_selection import train_test_split
from sklearn.neighbors import KNeighborsClassifier
from sklearn.metrics import accuracy_score, confusion_matrix

# Load your dataset from Excel
# Replace 'your_dataset.xlsx' with the actual path to your Excel file
df = pd.read_excel('ore_dataset.xlsx')

# Assuming 'Wavelength' and 'Concentration' are your features, and 'MineralType' is your target variable
X = df[['Wavelength', 'Concentration']]
y = df['MineralType']

# Split the dataset into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Create and train the k-NN model
knn_model = KNeighborsClassifier(n_neighbors=3)  # You can adjust the number of neighbors
knn_model.fit(X_train, y_train)

# Make predictions on the test set
y_pred = knn_model.predict(X_test)

# Evaluate the model
accuracy = accuracy_score(y_test, y_pred)
conf_matrix = confusion_matrix(y_test, y_pred)

print(f'Accuracy: {accuracy}')
print(f'Confusion Matrix:\n{conf_matrix}')

# Predict the mineral type for the entire dataset
df['PredictedMineralType'] = knn_model.predict(X)

# Display the results
print(df[['Wavelength', 'Concentration', 'MineralType', 'PredictedMineralType']])

img = cv.imread("s5.png")

# Display the image without axis
plt.imshow(img)
plt.title('Variation in spectroscopy readings for varying impurities in Haematite ore')
plt.axis('off')  # Hide axis
plt.show()